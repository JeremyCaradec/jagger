// Options for JavaCC.
options { LOOKAHEAD=1; FORCE_LA_CHECK=true; STATIC = false;}

// Fonction principale
PARSER_BEGIN(Cabeg)
public class Cabeg
{
}
PARSER_END(Cabeg)

// Characters to ignore.
SKIP: { " " | "\r" | "\t" | "\n"}

//Language's Keywords
TOKEN:
{
		< IF: "if" >
|		< THEN: "then" >
|		<	ELSE: "else" >
|		< LET: "let" >
|		< IN: "in" >
| 	< END: "end" >
|		< VAR: "var" >
|		< PRINT: "print" >
|		< RBR: ")" >
|		< LBR: "(" >
|		< INIT: ":=" >
|		< COMMA: "," >
}

// Token specifications.
TOKEN:
{
		< NUMBER: (<DIGIT>)+ ("." (<DIGIT>)*)? >  			// A decimal number.
|   < DIGIT: ["0"-"9"] >                      			// A decimal digit.
|		<	#STRING_LITERAL: ["a"-"z", "A"-"Z"]	>										// The alphabet
|		< ID: <STRING_LITERAL> (<STRING_LITERAL> | <DIGIT>)* > 				// An identifier.
|		< STRING: "\"" (<STRING_LITERAL> | <DIGIT> | " ")* "\""> 		// A string.
}

// Main loop: read expressions on a line until end of file.
// mainloop â†’ (expression <EOL>)* <EOF>
void mainloop():
{ Exp a; Scope s;}
{
    (
      	statement()
    )*
    <EOF>
}

void statement():
{ Exp e; }
{
		scope()
	|	<PRINT> <LBR> e=ternary() <RBR> {new PrintFunc(e);}
}

void scope():
{Scope s;}
{
		<LET> s = declaration() <IN> instructions() <END> {s.exit();}
}

Scope declaration():
{Token t; Exp e; Scope s = new Scope();}
{
	(
		<VAR> t=<ID> <INIT> e=expression() {s.addDeclaration(t.toString(), e);}
	)* {return s;}
}

void instructions():
{}
{
	statement()
	(
		<COMMA> statement()
	)*
}

Exp ternary():
{ Exp a,b,c; }
{
  (	
  <IF> a=ternary() <THEN> b=ternary() <ELSE> c=ternary() {a= new CondBranch(a,b,c);}
	| a = comp()
	)+	{return a;}
}

// Comparisons
// C => E ('<' E | '==' E | etc...)
Exp comp():
{ Exp a,b; }
{
	a = expression()
	(
	 	"<"  b=expression() { a = new Lt(a,b); 		}		
	| "<=" b=expression() { a = new Le(a,b); 		}
	| ">"  b=expression() { a = new Gt(a,b); 		}
	| ">=" b=expression() { a = new Ge(a,b);		}
	| "==" b=expression() { a = new Equal(a,b); }
	| "<>" b=expression() { a = new Nequal(a,b);}
	)?	{return a;}
}

// Expression (the axiom).
// E -> T ('+'E | '-'E | etc...)?
Exp expression():
{ Exp a,b; }
{
    a=term()
    (
      "+" b=term() { a = new Add(a, b);}
    | "-" b=term() { a = new Sub(a, b);}
    )* { return a; }
}


// Term.
// T -> U ('*'T | '/'T )*
Exp term():
{ Exp a,b; }
{
    a=unary()
    (
      "*" b=term() { a = new Mul(a, b); }
    | "/" b=term() { a = new Div(a, b); }
    )? { return a; }
}

// Unary
// U -> '-'F | '+'F | F
Exp unary():
{
    Exp a;
}
{
		  "-" a=factor()     { return new Neg(a); }
	|   "+" a=factor()		 { return a; }
	|   a=factor()         { return a; }
}

// Factor of an expression.
// F -> <NUMBER> | "(" E ")"
Exp factor():
{ Token t; Exp e; }
{
      t=<NUMBER> { return new Num(Double.parseDouble(t.toString())); }
    | "(" e=expression() ")" { return e; }
    | t = <ID> {return new Var(t.toString()); }
    | t = <STRING> {return new ExpString(t.toString());}
}
