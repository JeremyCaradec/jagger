// Options for JavaCC.
options { LOOKAHEAD=1; FORCE_LA_CHECK=true; STATIC = false;}

// Fonction principale
PARSER_BEGIN(Cabeg)
public class Cabeg
{
}
PARSER_END(Cabeg)

// Characters to ignore.
SKIP: { " " | "\r" | "\t" }

// Token specifications.
TOKEN:
{
		< NUMBER: (<DIGIT>)+ ("." (<DIGIT>)*)? >  // A decimal number.
|   < DIGIT: ["0"-"9"] >                      // A decimal digit.
|   < EOL: "\n" >                             // End of line.
|		< KEYWORD: "print" >										  // Keywords.
}

// Main lopp: read expressions on a line until end of file.
//     mainloop â†’ (expression <EOL>)* <EOF>
void mainloop():
{ Exp a; }
{
    (
      a=expression() <EOL> { new PPrinter(a); System.out.print("=" + new Eval(a).result()+ '\n');}
    )*
    <EOF>
}

// Expression (the axiom).
// E -> T ('+'T | '-'T)*
Exp expression():
{ Exp a,b; }
{
    a=term()
    (
      "+" b=expression() { a = new Add(a, b);}
    | "-" b=expression() { a = new Sub(a, b);}
    )? { return a; }
}

// Term.
// T -> U ('*'F | '/'F)*
Exp term():
{ Exp a,b; }
{
    a=unary()
    (
      "*" b=term() { a = new Mul(a, b); }
    | "/" b=term() { a = new Div(a, b); }
    |	"<" b=term() { a = new Lt(a,b); }
    | "<=" b=term() { a = new Le(a,b); }
    | ">" b=term() { a = new Gt(a,b); }
    | ">=" b=term() { a = new Ge(a,b); }
    | "==" b=term() { a = new Equal(a,b); }
    )* { return a; }
}

Exp unary():
{
    Exp a;
}
{
    "-" a=factor()     { return new Neg(a); }
|   "+" a=factor()		 { return a; }
|   a=factor()         { return a; }
}

// Factor of an expression.
// F -> <NUMBER> | "(" E ")"
Exp factor():
{ Token t; Exp e; }
{
      t=<NUMBER> { return new Num(Double.parseDouble(t.toString())); }
    | "(" e=expression() ")" { return e; }
}
